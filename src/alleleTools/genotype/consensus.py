"""
Consensus HLA Genotyping Module.

This module generates consensus HLA genotypes from multiple genotyping algorithm
results. It handles the integration of results from different HLA typing tools,
resolves conflicts, and produces high-confidence consensus calls. It is initially
designed to work with the JSON reports generated by the IKMB HLA genotyping pipeline.

Input formats:
- JSON reports from IKMB HLA genotyping pipeline

Author: Nicolás Mendoza Mejía (2023)
"""

import argparse
import json
import re
from collections import defaultdict
from enum import Enum
from typing import List

from ..argtypes import output_path


def setup_parser(subparsers):
    """
    Set up the argument parser for the consensus command.

    Args:
        subparsers: The subparsers object to add this command to.

    Returns:
        argparse.ArgumentParser: The configured parser for consensus.
    """
    parser = subparsers.add_parser(
        name="consensus",
        description="""
        This program finds a consensus between multiple HLA genotyping reports
        """,
        epilog="Author: Nicolás Mendoza Mejía (2023)",
    )
    parser.add_argument(
        "input",
        metavar="path",
        type=argparse.FileType("r"),
        nargs="+",
        help="JSON files with HLA genotyping reports to be processed",
    )
    parser.add_argument(
        "--output",
        metavar="path",
        type=output_path,
        help="Path to output file",
        default="output.alt",
    )

    parser.set_defaults(func=call_function)

    return parser


def call_function(args):
    """
    Main function to execute consensus genotyping.

    Processes multiple JSON genotyping reports and generates consensus
    HLA calls using evidence-based algorithms. Outputs results in
    allele table format.

    Args:
        args: Parsed command line arguments containing:
            - input: List of JSON file handles with genotyping reports
            - output: Path to output consensus file
    """
    for file in args.input:
        json_report = json.load(file)

        report = Report(json_report, resolution=2)

        consensus = ConsensusAlgorithm(report)
        alleles = consensus.get_flat_alleles()

        ##########################
        # Generate the output file
        ##########################

        with open(args.output, "a") as out:
            out.write("%s\t2\t%s\n" % (report.sample, "\t".join(alleles)))


def pairwise(iterable):
    """
    Iterate over a sequence in a pairwise manner.

    Args:
        iterable: Any iterable sequence

    Yields:
        tuple: Consecutive pairs from the iterable

    Example:
        >>> list(pairwise('ABCDEFG'))
        [('A', 'B'), ('B', 'C'), ('C', 'D'), ('D', 'E'), ('E', 'F'), ('F', 'G')]
    """

    iterator = iter(iterable)
    a = next(iterator, None)

    for b in iterator:
        yield a, b
        a = b


def get_allele_pair(alleles: List[str], resolution) -> List["Allele"]:
    """
    Parse and select the best allele pair from a list of allele strings.

    This function handles algorithm-specific logic, particularly for HiSat
    which returns ranked lists of alleles. It selects the two most confident
    alleles that meet the resolution requirements.

    Args:
        alleles (List[str]): List of allele strings to parse
        resolution (int): Desired resolution level (number of fields)

    Returns:
        List[Allele]: List of up to two Allele objects representing the best pair

    Note:
        For HiSat results, alleles with combined confidence >0.90 and meeting
        resolution requirements are preferred.
    """
    parsed_alleles = list()
    alleles.sort()
    for allele in alleles:
        try:
            parsed_allele = Allele(allele)
            parsed_alleles.append(parsed_allele)
        except Exception as e:
            print(f"Error: exeption {e}")
            print(f"The allele {allele} was not parsed")
            pass

    ##############################################################
    # Hisat specific section:
    # Given that Hisat returns a list of most abundant alleles,
    # this sections trys to use the ranking to come up with the
    # highest resolution and most abundant alleles
    ##############################################################

    # Check the abundance of alleles and discard if more than two
    pair = list()
    for pair in pairwise(parsed_alleles):
        abundance = 0
        for allele in pair:
            abundance += allele.confidence if hasattr(
                allele, "confidence") else 0.5
        resolution_is_met = all([len(a) > resolution for a in pair])

        if abundance > 0.90 and resolution_is_met:
            break

    ##############################################################
    # End of Hisat specific section
    ##############################################################

    # truncate the alleles to the desired resolution
    for allele in pair:
        allele.truncate(resolution)

    assert len(pair) <= 2, "More than two alleles found in call"

    return pair[:2]  # Return only the first two alleles, if any


class CmpResult(Enum):
    """
    Enumeration for allele comparison results.

    Defines the possible outcomes when comparing two alleles:
    - NOT_EQUAL: Alleles are different (different genes or field values)
    - EQUAL: Alleles are identical in gene and all fields
    - LESS_RESOLUTION: Current allele has fewer fields than compared allele
    - MORE_RESOLUTION: Current allele has more fields than compared allele
    """
    NOT_EQUAL = 1
    EQUAL = 2
    LESS_RESOLUTION = 3
    MORE_RESOLUTION = 4


class Allele:
    """
    Class representing an HLA allele with parsing and comparison capabilities.

    This class handles the parsing of HLA allele nomenclature and provides
    methods for comparison, resolution management, and string representation.
    It supports confidence scores from algorithms like HiSat.

    Attributes:
        gene (str): Gene name (e.g., 'A', 'B', 'DRB1')
        fields (List[str]): List of allele fields (e.g., ['01', '01', '01'])
        confidence (float): Optional confidence score from genotyping algorithm

    Args:
        code (str): Allele string to parse (e.g., 'A*01:01:01' or 'A*01:01(0.95)')

    Raises:
        Exception: If the allele string cannot be parsed

    Example:
        >>> allele = Allele('A*01:01:01')
        >>> print(allele.gene)  # 'A'
        >>> print(allele.fields)  # ['01', '01', '01']
        >>> print(len(allele))  # 3
    """

    def __init__(self, code: str) -> None:
        if not code:
            raise Exception("No allele to parse")

        # Extract allele name GENE*01:01:01
        allele_pattern = re.search(r"(\w+)\*(\d{2})(:\d{2})*", code)
        if not allele_pattern:
            raise Exception("Error no allele name parsable")

        # Extract confidence score (Hisat)
        confidence_score = re.search(r"\((.*?)\)", code)
        if confidence_score:
            self.confidence = float(confidence_score.group(1))

        allele_code = allele_pattern.group(0)
        self.gene, fields = allele_code.split("*")
        self.fields = fields.split(":")

    def __repr__(self) -> str:
        if not hasattr(self, "gene"):
            return "<Empty Allele>"
        return f"""({len(self.fields)}-fields){str(self)}"""

    def __str__(self) -> str:
        """
        String representation of the allele in standard HLA nomenclature.

        Returns:
            str: Allele in format 'GENE*field1:field2:field3'
        """
        if not hasattr(self, "gene"):
            return ""
        return f"{self.gene}*{':'.join(self.fields)}"

    def __len__(self) -> int:
        """
        Get the resolution level of the allele.

        Returns:
            int: Number of fields in the allele (resolution level)
        """
        return len(self.fields)

    def __eq__(self, allele_b: "Allele"):
        """Check equality with another allele."""
        return self.compare(allele_b) == CmpResult.EQUAL

    def __hash__(self):
        """Hash function for use in sets and dictionaries."""
        return hash(str(self))

    def truncate(self, new_resolution: int):
        """
        Reduce the resolution of the allele to the specified level.

        Args:
            new_resolution (int): Target resolution level (number of fields)

        Note:
            If new_resolution is greater than current resolution, no change is made.
        """
        if new_resolution > len(self):
            return
        self.fields = self.fields[:new_resolution]

    def compare(self, allele: "Allele") -> CmpResult:
        """
        Compare this allele with another allele.

        Performs detailed comparison considering gene name, field values,
        and resolution levels.

        Args:
            allele (Allele): The allele to compare with

        Returns:
            CmpResult: The result of the comparison

        Example:
            >>> a1 = Allele('A*01:01')
            >>> a2 = Allele('A*01:01:01')
            >>> a1.compare(a2)  # CmpResult.MORE_RESOLUTION
        """
        # Check that it belongs to the same gene
        if self.gene != allele.gene:
            return CmpResult.NOT_EQUAL

        # Compare each field
        for s_field, a_field in zip(self.fields, allele.fields):
            if s_field != a_field:
                return CmpResult.NOT_EQUAL

        # Check differences in resolution
        if len(self.fields) > len(allele.fields):
            return CmpResult.LESS_RESOLUTION
        elif len(self.fields) < len(allele.fields):
            return CmpResult.MORE_RESOLUTION

        return CmpResult.EQUAL


class Report:
    """
    Class for parsing and organizing HLA genotyping reports.

    This class handles JSON reports from HLA genotyping pipelines,
    organizing results by gene and algorithm for consensus analysis.

    Attributes:
        resolution (int): Target resolution level for alleles
        sample (str): Sample identifier from the report
        genes (Dict): Dictionary organizing calls by gene and algorithm

    Args:
        report (dict): JSON report dictionary from genotyping pipeline
        resolution (int): Desired resolution level (default: 2)
    """

    def __init__(self, report: dict, resolution: int = 2) -> None:
        self.resolution = resolution  # desired resolution in fields
        calls = report["calls"]
        self.sample = report["sample"]
        self.genes = dict()

        for gene, call in calls.items():
            self.genes[gene] = self.parse_call(call)

    def parse_call(self, call: dict) -> dict[Allele]:
        """
        Parse genotyping calls for a single gene from multiple algorithms.

        Args:
            call (dict): Dictionary with algorithm names as keys and
                        allele lists as values

        Returns:
            dict: Dictionary mapping algorithm names to allele pairs
        """
        alleles_by_alg = dict()

        for algorithm, alleles in call.items():
            two_alleles = get_allele_pair(alleles, self.resolution)
            alleles_by_alg[algorithm] = two_alleles
        return alleles_by_alg

    def __iter__(self):
        """
        Iterate over all allele calls in the report.

        Yields:
            dict: Dictionary with 'gene', 'program', and 'allele' keys
                 for each individual allele call
        """
        for gene, prog_calls in self.genes.items():
            for program, calls in prog_calls.items():
                for allele in calls:
                    yield {
                        "gene": gene,
                        "program": program,
                        "allele": allele
                    }


class ConsensusAlgorithm:
    """
    Algorithm for generating consensus HLA genotypes from multiple sources.

    This class implements an evidence-based consensus algorithm that:
    1. Collects allele calls from multiple genotyping algorithms
    2. Groups similar alleles and accumulates evidence
    3. Resolves conflicts by selecting higher resolution alleles
    4. Ensures proper diploid representation (exactly 2 alleles per gene)

    Attributes:
        consensus (defaultdict): Dictionary mapping genes to consensus alleles

    Args:
        calls (Report): Parsed genotyping report containing multiple algorithm results
    """

    def __init__(self, calls: Report) -> None:
        self.consensus = defaultdict(list)

        for report in calls:
            allele = report["allele"]
            gene = report["gene"]
            allele_cluster = self.consensus[gene]
            match = self.find_matching_allele(allele, allele_cluster)

            if not match:
                allele_cluster.append(self.AlleleWithEvidence(allele))
            else:
                match.add_evidence(allele)

                if match.compare(allele) == CmpResult.MORE_RESOLUTION:
                    match.fields = allele.fields

        self.correct_homozygous_calls(self.consensus)

    def correct_homozygous_calls(self, consensus: dict):
        """
        Ensure proper diploid representation for all genes.

        Corrects the number of alleles per gene to exactly two:
        - If >2 alleles: keeps only the first two (highest evidence)
        - If 1 allele: duplicates it (homozygous call)
        - If 0 alleles: fills with "NA" values

        Args:
            consensus (dict): Dictionary mapping genes to allele lists
        """
        for gene in consensus:
            n_alleles = len(consensus[gene])

            if n_alleles > 2:
                consensus[gene] = consensus[gene][:2]
            elif n_alleles == 1:
                consensus[gene] = consensus[gene] * 2
            elif n_alleles == 0:
                consensus[gene] = ["NA", "NA"]

    def find_matching_allele(
        self, allele: Allele, allele_list: list["AlleleWithEvidence"]
    ) -> "AlleleWithEvidence":
        """
        Find an existing allele in the consensus that matches the given allele.

        Args:
            allele (Allele): Allele to find a match for
            allele_list (list): List of existing consensus alleles

        Returns:
            AlleleWithEvidence: Matching allele if found, None otherwise
        """
        for a in allele_list:
            result = a.compare(allele)
            if result != CmpResult.NOT_EQUAL:
                return a
        return None

    def get_flat_alleles(self) -> list[str]:
        """
        Get a flat list of all consensus alleles as strings.

        Returns:
            list[str]: List of allele strings for all genes
        """
        return [str(c) for gene in self.consensus for c in self.consensus[gene]]

    class AlleleWithEvidence(Allele):
        """
        Allele class that tracks supporting evidence from multiple algorithms.

        Extends the base Allele class to maintain a list of supporting
        evidence from different genotyping algorithms, enabling confidence
        assessment and conflict resolution.

        Attributes:
            evidence (List[Allele]): List of supporting allele calls

        Args:
            allele (Allele): Initial allele to create evidence for
        """

        def __init__(self, allele: Allele) -> None:
            # Make a copy of the allele's attributes
            self.gene = allele.gene
            self.fields = allele.fields
            if hasattr(allele, "confidence"):
                self.confidence = allele.confidence

            self.evidence = [allele]

        def add_evidence(self, allele: Allele) -> None:
            """
            Add supporting evidence for this allele.

            Args:
                allele (Allele): Additional allele call supporting this consensus allele
            """
            self.evidence.append(allele)
